<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Ìå®ÌÑ¥ Ï∫îÎ≤ÑÏä§</title>
    <meta name="viewport" content="width=device-width">
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }
      body {
        overflow: hidden;
      }
      #myCanvas {
        display: block;
        width: 100%;   /* iframe Í∞ÄÎ°ú ÍΩâ Ï±ÑÏö∞Í∏∞ */
        height: auto;  /* iframe ÏÑ∏Î°ú ÍΩâ Ï±ÑÏö∞Í∏∞ */
      }
    </style>
  </head>
  <body>
  
  <canvas id="myCanvas" width="800" height="2000"></canvas>
<script>
  // ===================== Í≥µÌÜµ ÏÑ§Ï†ï =====================
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');
  
  // 1) Ï§Ñ Î∞∞Í≤ΩÎßå Ï†ÄÏû•ÌïòÎäî Ï∫îÎ≤ÑÏä§
  const rowBgCanvas = document.createElement('canvas');
  rowBgCanvas.width = canvas.width;
  rowBgCanvas.height = canvas.height;
  const rowBgCtx = rowBgCanvas.getContext('2d');
  
  // 2) Í∞ïÏïÑÏßÄ/Ïßë/ÏÜåÌíà Ïä§ÌîÑÎùºÏù¥Ìä∏Îßå Ï†ÄÏû•ÌïòÎäî Ï∫îÎ≤ÑÏä§
  const patternCanvas = document.createElement('canvas');
  patternCanvas.width = canvas.width;
  patternCanvas.height = canvas.height;
  const patternCtx = patternCanvas.getContext('2d');
  
  const PIXEL_SIZE = 3;
  const TOP_MARGIN = 0;
  const ROW_HEIGHT = 50;      // Ï§Ñ Í∞ÑÍ≤© (Ìå®ÌÑ¥ ÎÜíÏù¥ + Ïó¨Î∞±)
  const ROW_PADDING_TOP = 5;  // Ï§Ñ ÏïàÏóêÏÑú ÏúÑÏ™Ω Ìå®Îî©
  
  // ÌòÑÏû¨ Î™á Î≤àÏß∏ Ï§ÑÍπåÏßÄ ÏåìÏòÄÎäîÏßÄ
  let currentRow = 0;
  
  // Ï†ÑÏ≤¥ Î∞∞Í≤ΩÏÉâ (ÌåîÎ†àÌä∏ÏóêÏÑú ÏÑ†ÌÉù)
  let bgColor = '#4ECDC4';
  
  // ÎèÑÌä∏ ÏÑ§Ï†ï
  let dotSize   = 2;          // Î∞òÏßÄÎ¶Ñ
  const DOT_SPACING = 24;     // ÎèÑÌä∏ Í∞ÑÍ≤© (ÌîΩÏÖÄ)
  let dotColor = '#FFFFFF';   // nullÏù¥Î©¥ ÎèÑÌä∏ ÏóÜÏùå
  
  // Í∞Å Ï§Ñ ÌÉÄÏûÖÎ≥Ñ Î∞∞Í≤ΩÏÉâ
  const ROW_BG_COLORS = {
    1: null,          // poodle Ï§Ñ
    2: '#FFF6E0',     // retriever Ï§Ñ
    3: '#FFE8EE',     // Jindo Ï§Ñ
    4: '#F0FFF4',     // house Ï§Ñ
    5: null           // food Ï§Ñ
  };
  
  // ÏÉâÏÉÅ ÏΩîÎìú
  const COLORS = {
    'A': '#BE845D',
    'B': '#dbaa7d',
    'C': '#8c694b',
    'D': '#b78b63',
    'E': '#000000',
    'F': '#9D6742',
    'G': '#6d431d',
    'H': '#4c2e13',
    'I': '#930d0d',
    'J': '#ffb048',
    'K': '#ffe948',
    'L': '#ffd2cc',
    'M': '#513a25',
    'N': '#ffffff',
    'O': '#ed6a58',
    'P': '#EE899C',
    'Q': '#d7e1e2',
    'R': '#e24217',
    'S': '#69797a',
    'T': '#f4c290',
    'U': '#6fd146',
    'V': '#93E1A4',
    'W': '#EE899C',
    ' ': null // Ìà¨Î™Ö/Í∑∏Î¶¨ÏßÄ ÏïäÏùå
  };
  
  // ===================== ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ =====================
  
  // (1) Ìë∏Îì§ (ÏñºÍµ¥Îßå)
  const POODLE_PIXELS = [
    "         ",
    " HH  HHHHHH  HH ",
    "HAAFGFFAAFFGFAAH",
    "HAAAAAAAAAAAAAAH",
    "HFFAAAAAAAAAAFFH",
    " HHFAAAAAAAAFHH ",
    "   GAEAAAAEAG   ",
    "  HFAAAHHAAAFH  ",
    "  HFAAAAAAAAFH  ",
    "   HGFAAAAFGH   ",
    "    HHGGGGHH    ",
  ];
  
  // (2) Ìä§Î¶Ω ÍΩÉ
  const FLOWER_PIXELS = [
    "        ",
    "  R  R  ",
    "  RRRR  ",
    "  RRRR  ",
    "   RR   ",
    "V  RR  V",
    "VV VV VV",
    " V VV V  ",
    " VVVVV   ",
    "  VVVV   ",
    "   VV    ",
  ];
  
  // (3) Î¶¨Ìä∏Î¶¨Î≤Ñ
  const RETRIEVER_PIXELS = [
    "                ",
    "      MMMMM       ",
    "    MMTTTTTMM     ",
    "   MBBTTTTTBBM    ",
    "  MBTTTTTTTTTBM   ",
    " MBTBTTTTTTTBTBM  ",
    " MTTDTMTTTMTDTTM  ",
    " MBTCTTTTTTTCTBM  ",
    "  MCBTTTMTTTBCM   ",
    "   MBTTMPMTTBM    ",
    "    MBTTTTTBM     ",
    "     MMMMMMM      ",
  ];
  
  // (4) ÌïòÌä∏
  const HEART_PIXELS = [
    "         ",
    "         ",
    "  WW WW  ",
    " WWWWWWW ",
    " WWWWWWW ",
    "  WWWWW  ",
    "   WWW   ",
    "    W    "
  ];
  
  // (5) ÏßÑÎèóÍ∞ú
  const DOG_PIXELS = [
    "   S       S    ",
    "  SNS     SNS   ",
    "  SNS     SNS   ",
    " SNPNSSSSSNPNS  ",
    " SQPNNNNNNNPQS  ",
    " SQPNQNNNQNPQS  ",
    "SQNNNNNNNNNNNQS  ",
    "SNNNMNNNNNMNNNS ",
    "SNNNCNNNNNCNNNS ",
    "SQNNNNGGGNNNNQS ",
    " SQNNNNPNNNNQS  ",
    "  SQQNNNNNQQS   ",
    "   SSSSSSSSS    ",
  ];
  
  // (6) Ìä§Î¶Ω2 (ÏßÑÎèóÍ∞ú ÏòÜ)
  const TWINKLE_PIXELS = [
    "         ",
    "   K  K  ",
    "   KKKK  ",
    "   KKKK  ",
    "    KK   ",
    " V  KK  V",
    " VV VV VV",
    "  V VV V  ",
    "  VVVVV   ",
    "   VVVV   ",
    "    VV    ",
  ];
  
  // (7) Ïßë
  const HOUSE_PIXELS = [
    "                 ",
    "   KKF  II       ",
    "   KLF IRRI      ",
    "   FLFIRIIRI     ",
    "   FLIRIQQIRI    ",
    "   FIRINNNNIRI   ",
    "   IRIQNNNNQIRI  ",
    "  IRIQNNNNNNQIII ",
    "   SQNNNNNNNNQS",
    "   SNNNNNMMFNNS",
    "   SNNNNNMMLNNS",
    "   SQNNNNMMFNQS",
    "   SSSSSSSSSSSS",
  ];
  
  // (8) ÏÉàÏãπ
  const SPROUT_PIXELS = [
    "         ",
    "         ",
    "        J",
    "K        ",
    "         ",
    "    U    ",
    "         ",
    "         ",
    "         ",
    "  UU UU  ",
    "   UVU   ",
    "    V    ",
    " UUUVUUU ",
  ];
  
  // (9) ÎºàÎã§Í∑Ä
  const BONE_PIXELS = [
    "                ",
    "          SSS   ",
    "         SNQSS  ",
    "         SNNNQS ",
    "         SNQQQS ",
    "        SNQSSS  ",
    "       SNQS     ",
    "     SSNQS      ",
    "   SSNNQS       ",
    "  SNNNNS        ",
    "  SQQNQS        ",
    "   SSQQS        ",
    "     SS         ",
  ];
  
  // (10) Î∞•Í∑∏Î¶á
  const FOOD_PIXELS = [
    "               ",
    "                ",
    "                ",
    "       CC       ",
    "    CCDDCCC     ",
    "   CDCCCCCCC    ",
    "  IIIIIIIIIII   ",
    " IRRRRRPRRRRII  ",
    " IRRRPRRRPRRRI  ",
    "IRRRRRRPRRRRRRI ",
    "IRRRRRPPPRRRRRI ",
    " IIIIIIIIIIIII  ",
    "      ",
  ];
  
  // (11) ÏûëÏùÄ ÌïòÌä∏
  const HEART2_PIXELS = [
    "           ",
    "        ",
    "  RR RR ",
    " RRRRRRR",
    " RRRRRRR",
    "  RRRRR ",
    "   RRR  ",
    "    R   ",
    "        ",
  ];
  
  // ===================== Í≥µÌÜµ Í∑∏Î¶¨Í∏∞ Ìï®Ïàò =====================
  
  // Ïä§ÌîÑÎùºÏù¥Ìä∏(ÌîΩÏÖÄ ÏïÑÌä∏) Í∑∏Î¶¨Í∏∞ (patternCanvas Ïóê Í∑∏Î¶º)
  function drawPixelArt(pixelArray, startX, startY) {
    for (let row = 0; row < pixelArray.length; row++) {
      const pixelRow = pixelArray[row];
      for (let col = 0; col < pixelRow.length; col++) {
        const char = pixelRow[col];
        const color = COLORS[char];
  
        if (color) {
          const x = startX + col * PIXEL_SIZE;
          const y = startY + row * PIXEL_SIZE;
  
          patternCtx.beginPath();
          patternCtx.fillStyle = color;
          patternCtx.rect(x, y, PIXEL_SIZE, PIXEL_SIZE);
          patternCtx.fill();
        }
      }
    }
  }
  
  // ===================== ÎèÑÌä∏ Í∑∏Î¶¨Í∏∞ (ÏßÄÍ∑∏Ïû¨Í∑∏ Ìè¥Ïπ¥ ÎèÑÌä∏) =====================
  function drawDots() {
    if (!dotColor) return; // ÎèÑÌä∏ ÏóÜÏùå
  
    ctx.fillStyle = dotColor;
    const step = DOT_SPACING;  // ÎèÑÌä∏ Í∞ÑÍ≤©
    const r = dotSize;
  
    let rowIndex = 0; // y Ï§Ñ Î≤àÌò∏
  
    // y Î∞©Ìñ•ÏúºÎ°ú Ìïú Ï§ÑÏî©
    for (let y = step / 2; y < canvas.height; y += step) {
      // ÌôÄÏàò Ï§ÑÎßàÎã§ xÎ•º Î∞ò Ïπ∏(offset)ÎßåÌÅº ÏòÜÏúºÎ°ú Î∞ÄÍ∏∞
      const offset = (rowIndex % 2 === 0) ? 0 : step / 2;
  
      for (let x = step / 2 + offset; x < canvas.width; x += step) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      }
  
      rowIndex++;
    }
  }
  
  // Ï§Ñ Î∞∞Í≤Ω ÏÉâ Ï±ÑÏö∞Í∏∞ (rowBgCanvas ÏóêÏÑú Ìï¥Îãπ Ï§Ñ)
  function fillRowBackground(y, color) {
    if (!color) return; // null Ïù¥Î©¥ ÏïÑÎ¨¥ Í≤ÉÎèÑ Ïïà Ìï®
    rowBgCtx.fillStyle = color;
    rowBgCtx.fillRect(0, y, canvas.width, ROW_HEIGHT);
  }
  
  // ===================== Ìå®ÌÑ¥Î≥Ñ "Ìïú Ï§Ñ Í∑∏Î¶¨Í∏∞" Ìï®Ïàò =====================
  
  // Ìå®ÌÑ¥ 1: Ìë∏Îì§ + Ìä§Î¶Ω
  function drawPoodleFlowerRow(startY) {
    const P_F_GAP = 20;
    const P_F_REPEAT_COUNT = 10;
  
    const POODLE_WIDTH_CELLS = Math.max(...POODLE_PIXELS.map(row => row.length));
    const POODLE_HEIGHT = POODLE_PIXELS.length * PIXEL_SIZE;
    const POODLE_WIDTH_PX = POODLE_WIDTH_CELLS * PIXEL_SIZE;
  
    const FLOWER_WIDTH_CELLS = Math.max(...FLOWER_PIXELS.map(row => row.length));
    const FLOWER_HEIGHT = FLOWER_PIXELS.length * PIXEL_SIZE;
    const FLOWER_WIDTH_PX = FLOWER_WIDTH_CELLS * PIXEL_SIZE;
  
    const PATTERN_WIDTH_PX = POODLE_WIDTH_PX + P_F_GAP + FLOWER_WIDTH_PX + P_F_GAP;
    const START_X_INITIAL = 10;
  
    const START_Y_FLOWER_OFFSET = (POODLE_HEIGHT - FLOWER_HEIGHT) / 2;
  
    for (let i = 0; i < P_F_REPEAT_COUNT; i++) {
      const currentPatternStartX = START_X_INITIAL + (i * PATTERN_WIDTH_PX);
  
      drawPixelArt(POODLE_PIXELS, currentPatternStartX, startY);
  
      const currentFlowerStartX = currentPatternStartX + POODLE_WIDTH_PX + P_F_GAP;
      drawPixelArt(FLOWER_PIXELS, currentFlowerStartX, startY + START_Y_FLOWER_OFFSET);
    }
  }
  
  // Ìå®ÌÑ¥ 2: Î¶¨Ìä∏Î¶¨Î≤Ñ + ÌïòÌä∏
  function drawRetrieverHeartRow(startY) {
    const R_H_GAP = 20;
    const R_H_REPEAT_COUNT = 10;
  
    const RETRIEVER_WIDTH_CELLS = RETRIEVER_PIXELS[0].length;
    const RETRIEVER_HEIGHT = RETRIEVER_PIXELS.length * PIXEL_SIZE;
    const RETRIEVER_WIDTH_PX = RETRIEVER_WIDTH_CELLS * PIXEL_SIZE;
  
    const HEART_WIDTH_CELLS = HEART_PIXELS[0].length;
    const HEART_HEIGHT = HEART_PIXELS.length * PIXEL_SIZE;
    const HEART_WIDTH_PX = HEART_WIDTH_CELLS * PIXEL_SIZE;
  
    const PATTERN_WIDTH = RETRIEVER_WIDTH_PX + R_H_GAP + HEART_WIDTH_PX + R_H_GAP;
    const START_X_INITIAL = 10;
  
    const HEART_Y_OFFSET = (RETRIEVER_HEIGHT - HEART_HEIGHT) / 2;
  
    for (let i = 0; i < R_H_REPEAT_COUNT; i++) {
      const currentPatternStartX = START_X_INITIAL + (i * PATTERN_WIDTH);
  
      drawPixelArt(RETRIEVER_PIXELS, currentPatternStartX, startY);
  
      const currentHeartStartX = currentPatternStartX + RETRIEVER_WIDTH_PX + R_H_GAP;
      drawPixelArt(HEART_PIXELS, currentHeartStartX, startY + HEART_Y_OFFSET);
    }
  }
  
  // Ìå®ÌÑ¥ 3: ÏßÑÎèóÍ∞ú + Ìä§Î¶Ω2
  function drawDogTwinkleRow(startY) {
    const D_T_GAP = 19;
    const D_T_REPEAT_COUNT = 10;
  
    const DOG_ACTUAL_WIDTH_CELLS = 15;
    const DOG_HEIGHT_PX = DOG_PIXELS.length * PIXEL_SIZE;
    const DOG_WIDTH_PX = DOG_ACTUAL_WIDTH_CELLS * PIXEL_SIZE;
  
    const TWINKLE_WIDTH_CELLS = 11;
    const TWINKLE_HEIGHT_PX = TWINKLE_PIXELS.length * PIXEL_SIZE;
    const TWINKLE_WIDTH_PX = TWINKLE_WIDTH_CELLS * PIXEL_SIZE;
  
    const PATTERN_WIDTH = DOG_WIDTH_PX + D_T_GAP + TWINKLE_WIDTH_PX + D_T_GAP;
    const START_X_INITIAL = 10;
  
    const TWINKLE_Y_OFFSET = (DOG_HEIGHT_PX - TWINKLE_HEIGHT_PX) / 2;
  
    for (let i = 0; i < D_T_REPEAT_COUNT; i++) {
      const currentPatternStartX = START_X_INITIAL + (i * PATTERN_WIDTH);
  
      drawPixelArt(DOG_PIXELS, currentPatternStartX, startY);
  
      const currentTwinkleStartX = currentPatternStartX + DOG_WIDTH_PX + D_T_GAP;
      drawPixelArt(TWINKLE_PIXELS, currentTwinkleStartX, startY + TWINKLE_Y_OFFSET);
    }
  }
  
  // Ìå®ÌÑ¥ 4: Ïßë + ÏÉàÏãπ
  function drawHouseSproutRow(startY) {
    const HOUSE_SPROUT_GAP = 19;
    const HOUSE_SPROUT_REPEAT_COUNT = 10;
  
    const HOUSE_WIDTH_CELLS = Math.max(...HOUSE_PIXELS.map(row => row.length));
    const HOUSE_HEIGHT = HOUSE_PIXELS.length * PIXEL_SIZE;
    const HOUSE_WIDTH_PX = HOUSE_WIDTH_CELLS * PIXEL_SIZE;
  
    const SPROUT_WIDTH_CELLS = Math.max(...SPROUT_PIXELS.map(row => row.length));
    const SPROUT_HEIGHT = SPROUT_PIXELS.length * PIXEL_SIZE;
    const SPROUT_WIDTH_PX = SPROUT_WIDTH_CELLS * PIXEL_SIZE;
  
    const PATTERN_WIDTH = HOUSE_WIDTH_PX + HOUSE_SPROUT_GAP + SPROUT_WIDTH_PX + HOUSE_SPROUT_GAP;
    const START_X_INITIAL = 10;
  
    const SPROUT_Y_OFFSET = (HOUSE_HEIGHT - SPROUT_HEIGHT) / 2;
  
    for (let i = 0; i < HOUSE_SPROUT_REPEAT_COUNT; i++) {
      const currentPatternStartX = START_X_INITIAL + (i * PATTERN_WIDTH);
  
      drawPixelArt(HOUSE_PIXELS, currentPatternStartX, startY);
  
      const currentSproutStartX = currentPatternStartX + HOUSE_WIDTH_PX + HOUSE_SPROUT_GAP;
      drawPixelArt(SPROUT_PIXELS, currentSproutStartX, startY + SPROUT_Y_OFFSET);
    }
  }
  
  // Ìå®ÌÑ¥ 5: ÎºàÎã§Í∑Ä + ÌïòÌä∏2 + Î∞•Í∑∏Î¶á
  function drawBoneHeartFoodRow(startY) {
    const B_H_F_GAP = 15;
    const B_H_F_REPEAT_COUNT = 5;
  
    const BONE_WIDTH_CELLS = Math.max(...BONE_PIXELS.map(row => row.length));
    const BONE_HEIGHT = BONE_PIXELS.length * PIXEL_SIZE;
    const BONE_WIDTH_PX = BONE_WIDTH_CELLS * PIXEL_SIZE;
  
    const HEART2_WIDTH_CELLS = Math.max(...HEART2_PIXELS.map(row => row.length));
    const HEART2_HEIGHT = HEART2_PIXELS.length * PIXEL_SIZE;
    const HEART2_WIDTH_PX = HEART2_WIDTH_CELLS * PIXEL_SIZE;
  
    const FOOD_WIDTH_CELLS = Math.max(...FOOD_PIXELS.map(row => row.length));
    const FOOD_HEIGHT = FOOD_PIXELS.length * PIXEL_SIZE;
    const FOOD_WIDTH_PX = FOOD_WIDTH_CELLS * PIXEL_SIZE;
  
    const PATTERN_WIDTH = BONE_WIDTH_PX + B_H_F_GAP + HEART2_WIDTH_PX + B_H_F_GAP + FOOD_WIDTH_PX + B_H_F_GAP;
    const START_X_INITIAL = 10;
  
    const HEART2_Y_OFFSET = (BONE_HEIGHT - HEART2_HEIGHT) / 2;
    const FOOD_Y_OFFSET = (BONE_HEIGHT - FOOD_HEIGHT) / 2;
  
    for (let i = 0; i < B_H_F_REPEAT_COUNT; i++) {
      const currentPatternStartX = START_X_INITIAL + (i * PATTERN_WIDTH);
  
      drawPixelArt(BONE_PIXELS, currentPatternStartX, startY);
  
      const currentHeart2StartX = currentPatternStartX + BONE_WIDTH_PX + B_H_F_GAP;
      drawPixelArt(HEART2_PIXELS, currentHeart2StartX, startY + HEART2_Y_OFFSET);
  
      const currentFoodStartX = currentHeart2StartX + HEART2_WIDTH_PX + B_H_F_GAP;
      drawPixelArt(FOOD_PIXELS, currentFoodStartX, startY + FOOD_Y_OFFSET);
    }
  }
  
  // ===================== Î∞∞Í≤Ω + Î†àÏù¥Ïñ¥ Ìï©ÏÑ± =====================
  function redrawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  
    // 1) Ï†ÑÏ≤¥ Î∞∞Í≤ΩÏÉâ
    if (bgColor !== null) {
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
  
    // 2) Ï§Ñ Î∞∞Í≤Ω (rowBgCanvas)
    ctx.drawImage(rowBgCanvas, 0, 0);
  
    // 3) ÎèÑÌä∏ (Ï§Ñ Î∞∞Í≤Ω ÏúÑ, Í∞ïÏïÑÏßÄ ÏïÑÎûò)
    drawDots();
  
    // 4) Ïä§ÌîÑÎùºÏù¥Ìä∏ (Í∞ïÏïÑÏßÄ/Ïßë/ÏÜåÌíà)
    ctx.drawImage(patternCanvas, 0, 0);
  }
  
  // ===================== Î∞∞Í≤ΩÏÉâ Î≥ÄÍ≤Ω Ìï®Ïàò =====================
  function setBackground(color) {
    bgColor = color;
    redrawAll();
  }
  
  // ===================== ÎèÑÌä∏ ÏÑ§Ï†ï Ìï®Ïàò =====================
  function updateDotSize(value) {
    dotSize = Number(value);
    redrawAll();
  }
  
  function setDotColor(color) {
    dotColor = color; // null Ïù¥Î©¥ ÎèÑÌä∏ ÏóÜÏùå
    redrawAll();
  }
  
  // ===================== Î≤ÑÌäºÏóêÏÑú Ìò∏Ï∂úÌïòÎäî Ìï®Ïàò =====================
  function addPatternRow(type) {
    const rowTop = TOP_MARGIN + currentRow * ROW_HEIGHT;
  
    if (rowTop > canvas.height - ROW_HEIGHT) {
      alert("Îçî Ïù¥ÏÉÅ ÏåìÏùÑ Ïàò ÏóÜÏñ¥Ïöî!");
      return;
    }
  
    // 1) Ï§Ñ Î∞∞Í≤Ω (rowBgCanvas)
    const rowBgColor = ROW_BG_COLORS[type];
    fillRowBackground(rowTop, rowBgColor);
  
    // 2) Ïä§ÌîÑÎùºÏù¥Ìä∏Îäî patternCanvasÏóê, Ï§Ñ ÏïàÏóêÏÑú ÏÇ¥Ïßù ÏïÑÎûò
    const spriteY = rowTop + ROW_PADDING_TOP;
  
    if (type === 1) {
      drawPoodleFlowerRow(spriteY);
    } else if (type === 2) {
      drawRetrieverHeartRow(spriteY);
    } else if (type === 3) {
      drawDogTwinkleRow(spriteY);
    } else if (type === 4) {
      drawHouseSproutRow(spriteY);
    } else if (type === 5) {
      drawBoneHeartFoodRow(spriteY);
    }
  
    currentRow++;
    redrawAll();
  }
  
  // ===================== Îã§Ïö¥Î°úÎìú =====================
  function downloadPattern() {
    redrawAll();
  
    const link = document.createElement('a');
    link.download = `pattern-${Date.now()}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
  
    alert('Ìå®ÌÑ¥Ïù¥ Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§! üíæ');
  }
  
  // ===================== Ï¥àÍ∏∞ ÏÑ§Ï†ï =====================
  window.addEventListener('load', () => {
    redrawAll();
  });


// ====================================================
// Î∂ÄÎ™® ÌéòÏù¥ÏßÄ(SHSH.html)ÏóêÍ≤åÏÑú Î™ÖÎ†πÏùÑ Î∞õÎäî Î∂ÄÎ∂Ñ
// ====================================================
window.addEventListener("message", (event) => {
  const data = event.data;
  if (!data || !data.type) return;

  if (data.type === "addRow") {
    addPatternRow(Number(data.value));
  }

  if (data.type === "bg") {
    setBackground(data.value);
  }

  if (data.type === "dotSize") {
    updateDotSize(Number(data.value));
  }

  if (data.type === "dotColor") {
    setDotColor(data.value);
  }
});
</script>

</body>
</html>
